# 动态链接

## 为什么要动态链接

早期计算机中，静态链接的方式对计算机内存和硬盘空间浪费严重。

静态链接对程序的更新、部署和发布页会带来很多的问题。



动态链接的方法就是把程序的模块互相分割开来，形成独立的文件，而不是将他们静态的链接在一起，

就是不对那些组成程序的目标文件进行链接，等到程序需要的时候再进行链接，把链接这个过程推迟到了运行时再进行，这就是动态链接







### 动态链接的基本实现

动态链接涉及运行时的链接及多个文件的装载，必须要有操作系统的支持，因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有存储管理、内存共享、进程线程等机制再动态链接下也会有一些微妙的变化。

在Linux系统中，ELF动态链接文件被称为动态共享对象，简称共享对象，他们一般都是一些so文件为扩展名的一些文件；

在Windows系统中，动态链接文件被称为动态链接库，他就是我们经常简单的以.dll为扩展名的文件



**从本质上来说，普通可执行程序和动态链接库中都包含指令和数据，但是在使用动态链接库的情况下，程序本身被分成了程序主要模块和动态链接库，但实际上他们可以看作是整个程序的一个模块，程序模块可以指程序主模块页可以指动态链接库**



## 简单动态链接库例子



**共享对象的最终装载地址在编译时是不确定的**





![](F:\Learn\5Week\程序员的自我修养\6\IMG\5.png)







## 地址无关代码

静态共享库：固定地址，而且手工分配内存，需要考虑内存冲突的问题



**共享对象在编译时不能假设自己在进程虚拟地址空间中的位置**







### 装载时重定义

为了能够保证所有的共享对象在任意位置装载，静态链接中重定位



在链接的时候，把所有绝对地址的引用不作重定位，而把这一步推迟到装载时再完成，一旦模块装在地址确定，即目标地址确定



**在静态链接时重定位，那时的重定位叫做链接时重定位，而现在这种情况被称为装载时重定位，在Windows中，这种装载时重定位又被叫做基质重置**





### 地址无关代码



**装载时重定位是解决动态模板中绝对地址引用的办法之一，缺点在于指令部分无法在多个进程之间共享，这样就失去了动态链接节省内存的一大优势**



**PIC（地址无关代码）：把指令中哪些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本**



链接时重定位（静态链接）；装载时重定位（动态链接）





​                       指令跳转、调用                          数据访问

模块内部      （1）相对跳转和调用                   （2）相对地址访问

模块外部      （3）间接跳转和调用（GOT）     （4）间接访问（GOT）







### 共享模块的全局变量问题

如果一个共享对象lib.so中定义了一个全局变量G，而进程A和B都使用了lib.so，那么当进程A改变这个全局变量G的值的时，进程B中G会受到影响么？

不会，因为当lib.so被两个进程加载时，它的数据段部分在每个进程中都有独立的副本，从这个角度看，共享对象中的全局变量实际上和定义在程序内部的全局变量没什么区别。如果是线程，则有影响。





### 数据段地址无关性







## 延迟绑定

动态链接比i链接慢的主要原因是动态链接下对于全局静态的数据访问要进行复杂的GOT定位,然后间接寻址.

 

由于很多函数在程序执行过程中不一定被用到（错误处理函数，特殊功能模块），ELF采用了一种叫延迟绑定（Lazy Binding）的做法，基本思想就是当函数第一次被用到时才进行绑定。

 

操作系统如何确定动态连接器？

 

在动态链接的ELF可执行文件中，有一个专门的段叫做“.interp”，如果我们使用objdump来查看：







### “interp”段

使用objdump工具来查看“interp段”



![](F:\Learn\5Week\程序员的自我修养\6\IMG\6.png)



可执行文件所需要的动态链接器路径大部分都是在"/lib/ld-linux.so.2"

"/lib/ld-linux.so.2"在linux中通常是一个软链接







### "dynamic段"

为了表示动态链接这些模块之间的符号导出与导入关系，ELF专门有一个叫做动态符号表的段用来保存这些信息。这个段叫做“.dynsym”。







```shell
[root@VM_181_45_centos 4]# readelf -d Lib.so

Dynamic section at offset 0x4e8 contains 20 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x0000000c (INIT)                       0x2e8
 0x0000000d (FINI)                       0x498
 0x6ffffef5 (GNU_HASH)                   0xf8
 0x00000005 (STRTAB)                     0x1e4
 0x00000006 (SYMTAB)                     0x134
 0x0000000a (STRSZ)                      133 (bytes)
 0x0000000b (SYMENT)                     16 (bytes)
 0x00000003 (PLTGOT)                     0x15b4
 0x00000002 (PLTRELSZ)                   24 (bytes)
 0x00000014 (PLTREL)                     REL
 0x00000017 (JMPREL)                     0x2d0
 0x00000011 (REL)                        0x2b0
 0x00000012 (RELSZ)                      32 (bytes)
 0x00000013 (RELENT)                     8 (bytes)
 0x6ffffffe (VERNEED)                    0x280
 0x6fffffff (VERNEEDNUM)                 1
 0x6ffffff0 (VERSYM)                     0x26a
 0x6ffffffa (RELCOUNT)                   1
 0x00000000 (NULL)                       0x0

```







![](F:\Learn\5Week\程序员的自我修养\6\IMG\7.png)





## 动态链接的实现步骤

动态链接的步骤和实现：

动态链接的步骤基本分为三步：先启动动态连接器本身，然后装载所有需要的共享对象，最后是重定位和初始化。

但是对于动态链接器本身来说，它的重定位工作是由谁来完成的？ 

动态连接器本身通过自举（Bootstrap）来完成。

完成基本自举之后，动态连接器将可执行文件和连接器本身的符号表都合并到一个符号表当中，我们可以称它为全局符号表（Global Symbol Table）。

动态连接器按照各个模块之间的依赖关系，当有两个不同的模块定义了同一个符号时怎么办？

当一个符号需要被加入全局符号表时，如果相同的符号已经存在，则后加入的符号被忽略。

显示运行时链接：

动态库的装载则是通过一些列由动态连接器提供的API，具体是4个函数：打开动态库（dlopen）、查找符号（dlsym）、错误处理（dlerror）、以及关闭动态库（dlclose）。

dlopen()函数用来打开动态库，并将其加载到进程的地址空间，完成初始化过程。

void  *dlopen(const char *filename, int flag);

 

dlsym()，我们通过该函数找到所需要的符号。

dlsym(void  *handle,  char  *symbol);

 

