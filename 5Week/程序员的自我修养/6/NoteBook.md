# 可执行文件的装载与进程





## 进程虚拟地址空间

64位操作系统寻址能力：2^64

32位操作系统寻址能力:   2^32



**进程只可以使用那些操作系统分配给进程的地址，如果访问未经过允许的空间，那么操作系统就会捕获到这些访问，将进程的这种访问当作非法操作，强制结束进程**



Windows下AWE的方法：操作系统提供一个窗口映射方法，把额外的内存空间映射到进程地址空间来。然后根据需要将这个窗口映射到不同的物理空间块，使用时再进行映射，如果重复操作即可。





## 装载的方式

覆盖装入和页映射是两种经典的动态装载方法





### 页映射

与覆盖装入的方式相似，页映射也不是一下子就把程序的所有数据和指令都装入内存，而是将内存和所有磁盘中的数据和指令按照“页”为单位划分成若干个页，以后所有的装载和操作的单元就是页。

**硬件规定页的大小有4096个字节、8192个字节、2MB、4MB等，最常见的Intel IA32处理器一般都使用4096字节的页，那么512MB物理内存就拥有512 乘以 1024 乘以 1024 / 4096 = 131072个页**









## 从操作系统角度看可执行文件装载





### 进程的建立

一个进程最关键的特征是它拥有独立的虚拟地址空间，这使得它有别于其他进程

创建一个进程，然后装在相应的可执行文件并执行：

**1.创建一个独立的虚拟地址空间**

**2.读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系**

**3.将cpu的指令寄存器设置成可执行程序的入口地址，启动运行**





**由于可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件很多时候又被叫做映像文件**



LINUX中将进程虚拟空间中的一个段叫做虚拟内存区域；在Windows中将这个叫做虚拟段。





### 页错误

操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚存之间的映射关系，当CPU开始执行这个地址指令时，如果当前页是空页，于是它会认为这是一个页错误。









## 进程虚存空间分布

### ELF文件链接视图和执行视图



**ELF文件被映射时，是以系统的页长度作为单位的，那么每个段在映射时的长度应该都是系统页长度的整数倍，如果不是，那么多余的部分也将占用一个页**



**代码段的权限为可读可执行的段**

**数据段和BSS段为可读可写可执行的段**

**数据段为代表的权限为只读的段**



对于相同权限的段，把它们合同到一起当作一个段进行映射



所以引入一个新的概念“segmnet”;一个“segment”包含一个或多个属性类似的“Section”；

这样就节约了一部分内存空间



/*这里有一个比较坑的地方，我的环境gcc直接静态链接是不成功的，必须得找到静态静态链接库才可以    gcc -o 1.elf 1.c -L /home/crosstar/lib-static       */

![](F:\Learn\5Week\程序员的自我修养\6\IMG\0.png)

一共有29个段(Section),然后查看一下一共有多少个Segment。



![](F:\Learn\5Week\程序员的自我修养\6\IMG\1.png)





**总的来说，Segment和Section是从不同的角度来划分一个ELF文件**

![](F:\Learn\5Week\程序员的自我修养\6\IMG\2.png)





ELF中有一个专门的数据结构叫做程序头表用来保存“Segment”的信息





### 堆和栈

VMA(虚拟内存区域)除了用来映射可执行文件的各个“Segment”以外，它还可以有其他的作用，操作系统通过对VMA来对进程的地址空间进行管理。

**进程在执行的时候它还需要用到栈(Stack)和堆(Heap)等空间，事实他们子啊进程的虚拟空间中的表现页是VMA的形式存在的**



![](F:\Learn\5Week\程序员的自我修养\6\IMG\3.png)

段的所在设备主设备号和次设备号及文件节点号都是0，则标识他们没有映射到文件中，这种VMA叫做(匿名虚拟内存区域)。



**c语言中malloc申请内存分配函数就是从堆中申请，堆由系统库管理**



一个进程可以分为如下几种VMA区域：

​	1.代码VMA，权限只读、可执行；有映像文件

​	2.数据VMA，权限可读写，可执行；有映像文件

​	3.堆VMA，权限可读写、可执行；无映像文件，匿名，可向上扩展

​	4.栈VMA，权限可读写、不可知性；无映像文件，匿名，可向下扩展







### 堆的最大申请数量

Linux分配给进程本身是3GB（Windows 默认2GB），那么程序真实可以使用多少呢？



在linux中大概可以申请2.9G左右，在Windows中下大概是可以申请1.5G左右









### 段地址对齐

可执行文件最终都是要被操作系统装载运行的，这个装载的过程一般是通过虚拟内存的页映射机制来完成的，映射过程中，页是映射的最小单位。

在Intel 80x86系列的处理器来说，默认页的大小为4096个字节，也就是说，我们要将一段物理内存和进程虚拟地址空间之间建立映射关系，这段内存空间的必须是4096的整数倍。并且这段空间在物理内存和进程虚拟地址空间中的起始地址必须是4096的整数倍









### 进程栈的初始化



系统启动运行的时候，最基本的就是系统环境变量和进程运行参数。很常见的一种做法就是操作系统在进程启动前提前将这些信息保存到进程的虚拟空间栈中。











## Linux内核装载ELF过程



用户层面：bash(shell)会调用fork()系统调用创建一个新的进程，然后新的进程调用execve()系统调用执行制定的ELF文件，原先的bash进程继续返回等待刚才启动的新进程结束，然后继续等待用户输入命令。

execve()系统调用被定义在unistd.h中，它的原型如下:

```c
int execve(const char *filename,char *const argv[],char *const envp[]);
```





## Windows PE的装载

在PE文件中，所有段的起始地址都是页的倍数，段的长度如果倍数页的整数倍，那么映射时向上补齐到页的整数倍，在32位系统中，段的起始地址和长度都是4096字节的整数倍

PE文件中，链接器在生成可执行文件时，往往将所有的段尽可能的合并，所以一般只有**代码段、数据段、只读数据段、BSS段等几个段**



**RVA相对虚拟地址，相当于文件中的偏移量**





每个PE文件装载时都有一个装载目标地址，这个地址就是所谓的基地址，由于PE文件被设计可以装载到任何地址，所以这个基地址并不是固定的。





PE文件装载过程：

​	1.先读取文件的第一个页，在这个页中，包含了DOS头，PE文件头和标段

​	2.检查进程地址空间中，目标地址是否可用，如果不可用，选择其他地址进行装载

​	3.使用段表中提供的信息，将PE文件中的所有段的段一一对应应映射到地址空间中相应的位置

​	4.如果装地址不是目标地址，则进行Rebasing

​	5.装载所有PE文件所需要的DLL文件

​	6.对PE文件中的所有导入符号进行解析

​	7.根据PE头中指定参数，建立初始化栈和堆

​	8.建立主线程并且启动进程





![](F:\Learn\5Week\程序员的自我修养\6\IMG\4.png)

