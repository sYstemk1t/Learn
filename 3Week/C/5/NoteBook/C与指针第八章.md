# 数组

## 一维数组

```c
int a;
int b[10];

```



有时候我们需要多个相同类型的值，但是使用第一种定义方式过于繁琐，所以我们引入了数组的概念，数组就是多个相同类型的元素的合集。

但是这个时候b代表什么？b代表的是整个数组名，并且b是数组下标的第一个元素



**数组名并不用指针常量来表示----数组名做sizeof操作符或弹幕操作符&的操作数时**



```c
int a[10];
int b[10];
int *c;
c = &b[0];
c = b;
a = c;	//错误写法

```

这个时候的c=b代表的就是c=b这个数组中第一个元素的值。



**表达式&b[0]是一个指向数组第一个元素的指针**

如果理解了&b[0]是代表首元素，那么数组名代表的也是首元素，那么第五行代码就很容易可以理解了。

那么第六行是神恶魔意思呢，c是一个指针变量，a是一个数组，把c赋值给a，这样的写法是错误的，a是一个常量，不可以被修改。

### 下标引用

```c
int a[10];
int b[10];
int *c;
c = &a[0];
*(b+3);	//这句的意思是：取b这个数据，下标3的内容

```



在使用下标的地方，也可以通过对等的指针表达式来代替

int array[10];

int *ap = array+2;

array+2这个表达式代表的是array[0]+array[2] = array[2];





如果需要指针操作数组的时候：

*(ap+(0))这样就是操作了这个数组的第0个元素

*(array+2)和上面的表达式对等



ap+6,这个个表达式就是看当前的ap指向数组中的第几个元素，然后向后移几个元素



*ap+6，这个和上一个不一样的，这个有一个优先级的问题，这个表达式中会先找到间接引用，然后用间接引用的值和6相加



*(ap+6),括号的优先级大于一切，所以先计算括号内容，然后取内容



&ap,对ap进行取地址



ap[-1],如果这个时候ap指向第三个元素，那么-1，就是指向第二个元素，array[1];



ap[9]，当前的ap指向的元素是2，但是这个数据只有10个，9+2等于11，访问越界了



2[array]，这个表达式拆解开的意思：*(array+2)，相当于下标加2



### 指针与下标

**下标绝不会比指针更有效率，但是指针有时候会比下标更有效率**



```c
#include <stdio.h>

int main()
{
    int array[10];
    int i;
    for(i=0;i<10;i++)
    {
		array[i] = 0;       
    }
}

```





```c
#include <stdio.h>
int main()
{
    int array[10];
    int i;
    int *p;
    for(p = array;p<array+10;p++)
    {
        *p = 0;
    }
}

```

上面简单的实现两种方法，把一个数组内的所有内容全部归为0





## 指针效率

指针有时候比下标更有效率，前提是他们得被正确的使用。





## 数组和指针

数组和指针并不是相等的

声明一个数组的时候，编译器会根据数组的大小以及类型为它开辟一块内存空间。

声明一个指针的时候，编译器只为指针本身保留内存空间，它并不为任何数据类型分配内存空间



## 作为函数参数的数组名

如果把一个数组名做参数传递给函数，调用函数实际上传递的是一个指针，所以函数的形参实际上是个指针

讲字符串b中的内容拷贝到字符串a中，虽然c语言提供了很多库函数

```c

int strcpy_acpy(char *buf, char *str)
{
	while ((*buf++ = *str++) != '\0' )
	{
		if (*buf == '\0')
		{
			return 0;
		}
	}
}
int main()
{
	char a[10] = "hello";
	char b[5] = "world";
	strcpy_acpy(a, b);
	printf("%s", a);
}

```





## 声明数组参数

调用函数时实际传递的是一个指针，所以函数的形参是个指针

但是编译也接受数组形式的函数形参



int strlen_len(char *string);

int strlen_len(char string[]);

其实他们两个传递的值是相等的





## 初始化

 int array[10] = {1,2,3,4,5,6,7,8,9,10};

这样就是初始化了一个数组，所以array的值就是10

写一个我学c语言的时候犯的错误

```c
int main()
{
	int array[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	printf("%d\r\n", array);
	system("pause");
}

```

这个代码最后打印的时候值并不是1，但是前面说了，数据名相当于第一个元素，但是这里打印出来的是一个数组，这里就有一个问题就是，如果以整形的方式的打印数组，就会出问题，格式化输出的形式是整形，但是我们的类型是一个数组。





## 不完整的初始化

int array[10] = {1,2,3,4,5,6};

如果我们这么些，也是初始化，只是没有将元素和个数对应上，对于这种赋值，编译器会帮我们把后面的参数都填充为0

![](D:\Learn\3Week\C\5\img\12.png)

只要对数据中的第一个值进行了初始化，后面的部分都会填充为0



## 自动计算数组长度



int array[] = {1,2,3};

这个时候，其实编译器就会帮我们填充这个数组有多大

![](D:\Learn\3Week\C\5\img\13.png)

比较直观的看出来，这个数组有几个元素

我们中间使用了一个比较投机的办法，

sizeof(array)	//求这个数组有多大，因为是int型数组，所以每个元素占4字节，然后再处以int



## 字符数组初始化

**字符是单引号，字符串是双引号**

char array[] = {'h','e','l','l','0'};	//字符数组

char array[] = {"hello"};				//字符串数组



简单的区别就是字符串需要使用%s格式化输出符号，字符使用%c





# 二维数组

如果数组的维度不止一个，那么就称为多维数组

int max[6][10];





### 存储顺序

int array[3];	

![](D:\Learn\3Week\C\5\img\14.png)

可以看到数组在内存中是顺序存储的，那么二维数组是怎么存储的呢



![](D:\Learn\3Week\C\5\img\15.png)



可以看到，在内存中是4字节对齐的数据，每一个元素中都有自己的存储单元。







## 数组名

一维数组名的值是一个指针常量，它的类型是“指向元素类型的指针”，它指向数组的第一个元素，多维数组也是一样的，唯一的区别是多维数组的第一维的元素实际上是另一个数组

int array[10];	首元素是array[0]

int artay[10][];	首元素是array[0][0]

array[3][10];	//它的含义是3个元素，每个元素内有10个整形元素



## 下标

如果要精确的找到多维数组中的某个元素，那么必须按照数组声明时的顺序为每一维提供一个下标



int array[3][10];



如果要在这个数组中找到某一个指定元素

array [1][5]





那么用指针的形式写法就是：

*(*(array + 1)+5);	array代表的是十个元素，加一以后，指向下一个十个元素，然后再加五





*(array[1]+5);	array[1]代表的是一个子数组，所以访问的指针是指向一个整形的指针



## 指向数组的指针

指向二维数组的指针和指向一维数组的指针其实大同小异

int array[100];

int *p = array;

int array1[3][10];

int (*p1)[10] = array1;

上面的写法是正确的写法

p1是一个指针，指向具有10个整形元素的数组

记住p1的指向是0





如果要是理解不了可以这么写

int *pi = &array1[0][0];

int *py = array[0];

这两种写法都是使这个指针指向第一个整形元素







## 作为函数参数的多维数组

void fun(int (*p)[10]);

void fun(int p[][10])

以上的两种写法都可以作为函数的参数进行传递

我们可以在声明的时候，不写第一维度，但是第二维度一定要写



## 初始化

int array[2][5] = {{1,2,3,4,5},{6,8,9,9,10}};	//这是完整的初始化

int array[][5] = {{1,2,3,4,5},{1,3,4},{1,2},{1,9,9}};	//这个就是不需要写第一维度，编译器经过计算后，会自动帮助补全,包括里面的内容，如果不足5的，会自动补0



## 指针数组

int (*p)[10];	



**下标的优先级高于间接访问**







## 总结

指针名的值是指向数组第一个元素的指针

sizeof返回的是整个数组的大小

&单目操作符返回一个指向数组的指针，而不是指向一个数组第1个元素的指针的指针



指针的声明只分配了用于容纳指针本身的空间

数据的声明会分配用于容纳数组元素的内存空间





数组也可以用初始化列表进行初始化





多维数组是一维数组的衍生，多维数组可以看成一维数组





