# 指针

## 内存和地址

内存中一般数据称为字节（byte），一个字节占八位，这也就是为什么我们在vs中看到内存单元都是二字节并列在一起。在许多现代的计算机中，一个字节可以占八位，然后每一个内存单元的寻址是从0-f（十六进制）。

我们在学习汇编的时候，学习了字的概念，每个字由2-4个字节组成，（字单元也分高位和低位）。



尽管了一个字包含了4个字节，但是它仍然只有一个内存地址（不可重复）。



**硬件依然是通过地址访问内存位置**





## 值和类型

**int a = 123;	//4字节**

**float c = 3.14;	//2字节**

**int *b = &a;	//4字节，指针就占这么多**

**float *d = &c;	//4字节，无论任何类型的指针都是4字节**







## 指针变量的内容

```c
int a = 123,b = -1;
float c = 3.14;
int *d = &a;

```



执行完毕后

```c
	int a = 123, b = -1;
	float c = 3.14;
	int *d = &a;
	float *e = &c;

	printf("%d\r\n", a);
	printf("%d\r\n", b);
	printf("%f\r\n", c);
	printf("%d\r\n", *d);
	printf("%f\r\n", *e);
	system("pause");

```

![](D:\Learn\3Week\C\5\img\5.png)

为什么加了负号，但是还是正常打印了呢，默认的int是一个有无符号叔，但是可以通过unsigned这个参数来定义有无符号。

**如果要打印指针所对应的变量的值，记得要加*，*在中指针中代表取内容**

## 间接访问操作符

![](D:\Learn\3Week\C\5\img\6.jpg)

定义的时候是这样的，我们通过指针来修改变量a的值和变量b的值一样

![](D:\Learn\3Week\C\5\img\7.png)



**如果要让一个指针等于一个变量中的值，那么必须加上&，因为指针的操作都是在内存中，所以需要取地址符号**





## 未初始化指针和非法的指针

```c
int *a;
*a = 12;

```

上面就是一个常见的错误，这两行代码说明了定义个a指针变量，然后给a里赋值一个整形，但是为什么错了呢？没有考虑过a到底指向的是什么？

![](D:\Learn\3Week\C\5\img\8.png)

在vs中调试，vs直接抛异常，证明了错误，这个时候vs的监视窗口也不知道a到底指向哪一块内存地址，而且代码中你还要为这一块不知道在哪里的内存赋值，所以报错了。



正确的写法：

![](D:\Learn\3Week\C\5\img\9.png)



## NULL指针



c语言标准中定义了NULL指针，它作为一个特别的指针变量，表示不知想任意东西。



**你就是一个没人要的野指针...**





如果定义一个指针，并且不给他进行初始化的时候，这个时候，这个指针就是一个野指针，因为没有任何人知道它指向的是什么。



比如说还有我们用的无类型指针void *；





## 指针、间接访问和左值

**左值：就是写在表达式左边的值，可以是变量**

### 间接访问

```c
int a;
int *d =&a;

*d = 10 - *d;	//d = 10 - a的值
d = 10 - *d;	//结果保存在一个指针变量中，

```

当表达式中包含指针类型的时候，使用指针类型去接受它的值，不然的话，最后的结果将无法预料

在vs2013中，上面的写法并无语法的错误，但是结果并不是想要的结果





## 指针、间接访问和变量

```c
*&a = 25;

```

上面语句的意思是把25赋值给变量a。

&操作符产生变量a的地址，它是一个指针常量。

*操作符访问其操作数表示的地址，操作数是a的地址，所以值25存储与a中。

起始它和a = 25的功能是相同的。



## 指针常量

**没懂的章节**

int b = 100;

int *a = &b;

*(int *)100 = 25;	//100是一个整形，但是c语言的命名规范不允许出现数字开头啊，就当100是常量，那100是指向那里的？



## 指针的指针

```c
int a = 12;
int *b = &a;

```

他们的内存分配就是：

变量a去开辟了一块内存，然后指针b指向变量a，这个时候，他们两个共同使用这块内存空间

```c
int a = 12;
int *b = &a;
int **c = &b;

```

这个时候内存分配就是：

变量a去开辟了一块内存，然后指针b指向变量a，这个时候，他们两个共同使用这块内存空间，然后这个时候c也来了，直接等于指针b指向的内存位置，这个内存位置里存储的是什么呢？就是12；

他们三个变量都指向了同一块内存空间。

![](D:\Learn\3Week\C\5\img\10.png)

可以简单的理解就说：指向指针的指针，就得是两个**，几级指针，就有几个星号





## 指针表达式

```c
char ch = 'a';
char *cp = &ch;

```



```c
	char ch = 'a';
	char *cp = &ch;
	*(cp+1);
	system("pause");

```

**指针是可以执行和变量一样的自增运算，但是得考虑优先级，（）的优先级比较高**

上面的例子可能不太直观

![](D:\Learn\3Week\C\5\img\11.png)

看cp变量中的内容，存储的是一个地址。



&ch ：右值，表示ch的地址信息，ch的地址是0x033fd0f

cp ：右值，表示cp中的内容，即ch的地址信息

&cp ： 右值，表示cp的地址信息，即ch地址中的数据

*cp ： 右值：表示ch中的内容，左值：表示ch这个地址空间

*cp + 1： 右值： 首先把a字符做一次拷贝，然后+1，得到b，不可以做左值

*(cp+1): 右值:它作为指针加法运算的结果的一个右值，表示ch的下一个地址，做右值就是读取ch下一个地址中的数据内容，做左值表示ch下一个地址空间

++cp与cp++ ：做坐右值都因为没有清晰的位置定义，所以不合法，不用背

*++cp与*cp++ ： 进行了一次指针运算即间接访问操作，对于右值来说，就是自增一次内存空间对应的数据，对于左值来说，就是地址信息

```c

int main()
{
	char ch =  'a';

	char *cp = &ch;
	
	char *cd = NULL;
	

	printf("%p\r\n", &ch);
	printf("%c\r\n", ch);
	printf("%p\r\n", cp);
	printf("%p\r\n", &cp);
	printf("%c\r\n", *cp);
	printf("%p\r\n", cp);
	
	cd = *cp + 1;
	printf("%p\r\n", &ch);
	printf("%c\r\n", cd);
	cd = *++cp;
	printf("%p\r\n", &cd);
	

	cd = *(cp + 1);
	printf("%c\r\n", cd);
	
	

}

```



## 实例

计算字符串的长度

```c
int strlen_len_len(char *s)
{
	int i = 0;
	char *p = s;
	while (*p++ || *p != '\0')
	{
		i++;
	}
	return i;
}

int main()
{
	char *s = "hello";
	int i;
	i = strlen_len_len(s);
	printf("%d\r\n", i);
}

```



字符串查找

```c

char find(char *s,char name)
{
	char *p = s;
	while (*p++ != '\0')
	{
		if (*p == name)
		{
			return *p;
		}

	}
	return 0;
}

int main()
{
	char c = 0;
	char *s = "iamstudent";
	char a = 'u';
	c = find(s, a);
	printf("%c\r\n", c);
}

```



## 指针运算

指针之间的运算，如果是一个int+float呢，**所有的指针都是占4个字节**，所以无论怎么算，哪怕它是一个双精度浮点数，做加法也是将float调整（相乘）。

比如使用float类型的指针+3的表达式，这个3将根据float的大小，成衣4，这样，相当于我们的整形指针现在的值就是12



### 算术运算

c的指针算术运算只限于两种形式，（+、-）

并且这类表达式的结果也是指针。

指针做加法：

```c
#include <stdio.h>

float values[5];
flaot *cp;
for(vp = values[0];vp<values[5];)
{
    *vp++ = 0;
}

```



指针做减法：

两个指针相减的结果类型是ptrdiff_t，它是一种有符号的证书类型。

**减法运算的值是两个指针在内存中的距离（以数组元素的长度为单位），因为减法运算的结果是将除以数组运算类型的长度**



**指针都是4字节**



### 关系运算

对指针执行关系运算也是有限制

**<	<=	>	>=**

不过前提是他们都是指向同一数组的元素

```c
{
	float values[5];
	float *p;
	for (p = &values[5]; p > &values[0];)
	{
		*--p = 0;
	}

	for (int i = 0; i < 5; i++)
	{
		printf("%f\r\n", values[i]);
	}
}

```



**错误的例子**

```c
int main()
{
	float values[5];
	float *p;
	for (p = &values[5 - 1]; p >= &values[0];p--)
	{
		p = 0;
	}


	for (int i = 0; i < 5; i++)
	{
		printf("%f\r\n", values[i]);
	}

}

```

上面的例子错误的原因是，vp >= &values[0]的值是未定义的，因为vp移动到了数组的边界之外，所以就死循环了。





## 总结

**计算机内存中的每个地址都有一个地址标识**

**通常临近的内存组成一组，这样就允许内存存储更大的值**

**指针之间做运算的时候需要进行类型的强制转换**

**声明一个指针变量并不会和声明一个变量一样会自动分配内存**

**NULL指针就是不指向任何变量或者内存的指针**

**声明一个指针最好对他进行初始化**

**指针也可以进行加减法运算**

**如果两个指针指向同一块内存空间，那么有一个指针对这块内存进行修改，这块内存就会修改**

## 警告

不可以对未初始化的指针进行解引用

向函数传递null指针



