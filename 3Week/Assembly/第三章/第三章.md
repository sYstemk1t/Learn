# 存储器（内存访问）

## 内存中字的存储

![](D:\Learn\3Week\Assembly\第三章\img\1.png)

**4E20H，0号单元是低地址单元，1号单元是高地址单元。**

**0、1两个内存单元存储1个字**

**字单元，存放一个字形数据（16位）的内存单元，由两个地址连续的内存单元组成；**

**高地址内存单元中存放自行数据的高位字节，低地址内存单元中存放字形数据的低位地址；**





## DS寄存器

CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址；

在8086CPU中，内存地址由段地址和偏移地址组成；

在8086CPU中由一个DS寄存器，通常用来存放要访问数据的段地址；



**mov al,[0]		【】代表一个内存单元，【...】中的0代表内存单元的偏移地址**  



执行指令时，8086CPU自动读取DS中的数据为内存单元的段地址；

**mov bx,1000**

**mov ds,bx**	//段地址送入ds

**mov ax,[0]**	//这句话的意思是将1000：0地方的数据送入ax中

怎么样将数据从寄存器送入内存单元？

**mov bx,1000**

**mov ds,bx**	//段地址送入ds

​				//以上两部确定段地址

**mov [0],ax**	//这句话的意思是将ax中的数据送入1000:0这个偏移地址中

## 字的传送

8086CPU是16位结构的，有16根数据线，所以可以一次性传送16位的数据，也就是一次传送一个字；

mov ax,1000

mov ds,ax

mov ax,[0]

mov bx,[2]

mov cx,[1]

add bx,[1]

add cx,[2]

//这道题主要考的是对地址的高八位和低八位的计算。

//低地址在上，高地址在下。





问题3.4：（没做出来）

mov ax,1000

mov ds,ax

mov ax,11316	//没做出来的原因是当时没想明白，直接把11316当成16进制舍弃掉了1，直接计算1316

ax = 2c34

34

2c

22

11

bx = 2c34



2c34

1122

1b12

bx = 1b12





## mov、add、sub指令



**mov的几种格式：**

mov 寄存器，数据	mov ax,8

mov 寄存器，寄存器	mov ax,bx

mov 寄存器，内存单元	mov ax,[0]

mov 内存单元，寄存器	mov [0],ax

mov 段寄存器，寄存器	mov ds,ax

//谨记：数据不可以直接写入段寄存器，必须通过一个通用寄存器来中继





mov 寄存器，段寄存器	mov ax,ds

mov 内存单元，段寄存器	mov ax,1000	//1000代表段寄存器，1000代表基址，默认：0的偏移地址

mov 段寄存器，内存单元	mov ds,[0]

//不允许直接将数据写入段寄存器



**以上的操作sub指令也可以完成。**



add 寄存器，数据	add ax,8

add 寄存器，寄存器	add ax,bx

add 寄存器，内存单元	add,ax,[0]	//内存地址为偏移地址

add 内存单元，寄存器	add,[0],ax

sub 寄存器，数据	sub ax,8

sub 寄存器，寄存器	sub ax,bx

sub 寄存器，内存单元	sub ax,[0]

sub 内存单元，寄存器	sub [0],ax

//记住，add和sub不能操作段寄存器



## 数据段

对于一组内存单元定义为一个段。

我们可以将一组长度为n（n<=64kb）、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。

mov ax,123b

mov ds,ax

mov ax,0

add ax,[0]	//偏移第一个字（偏移位置为0）加到ax中

add ax,[2]

add ax,[4]

//字型数据占两个单元，所以偏移地址为0、2、4







**字在内存中存储的时候，需要用两个地址连续的内存单元来存放，字的低位放在低位，字的高位放在高位**

**段地址默认在DS寄存中**

**在内存和寄存器之间传递字型数据的时候，高低位单元和高8位寄存器、低位单元和低8位寄存器相对应**

**mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的**



![](D:\Learn\3Week\Assembly\第三章\img\2.png)

**jmp是一条特殊的指令，他的跳转方式多样，可以跳转到寄存器，也可以跳转到基质：偏移地址的地方**





监测点3.1

(1)

mov ax,1

mov ds,ax		ax = 0001	ds = 0001

mov ax,[0000]	ax = 2662

mov bx,[0001]	bx = e626

mov ax,bx		ax = e626

mov ax,[0000]	ax = 2662

mov bx,[0002]	bx = d6e6	//这里其实是有一点坑的，因为字的传输都是2字节传输，所以偏移地址0001，代表的是e6这里，0002代表的是d6这里。

add ax,bx		ax = fd48

add ax,[0004]	ax = 2c14		0004 = 2ecc

mov ax,0		 ax = 0000

mov al,[0002]	ax = 00e6

mov bx,0	     bx = 0000

mov bx,[000c]	bl = 0026	//这里没明白，正常的计算，0000是c代表的位置。

add al,bl		ax = 000c



(2)

1.写出cpu执行的指令序列：

cs = 2000H，先执行mov ax,6622 

jmp 0ff0：0100	跳转到0ff0*10H+100H=10000H这个地址上。	//其实这句也不是很理解，为什么有时候需要跳转，有时候不需要。

mov ax,2000	ax = 2000

然后继续执行mov ds,ax	ds = 2000

继续执行 mov ax,[0008]	ax = c389

继续执行 mov ax,[0002]	ax = ea66

执行顺序：

​    mov ax，6622H

​    jmp 0ff0:0100

​    mov ax，2000H

​    mov ds，ax

​    mov ax，[0008]

​    mov ax，[0002]

2.写出cpu执行每条指令后，cs、ip和相关寄存器中的数值

​    mov ax，6622H	ax = 6622; cs = 2000; ip = 0; ds = 1000

​    jmp 0ff0:0100	ax = 6622; cs = 0ff0; ip = 0100; ds = 1000

​    mov ax，2000H	ax = 2000; cs = 0ff0; ip = 0103; ds = 1000

​    mov ds，ax	ax = 2000; cs = 0ff0; ip = 0105; ds = 2000

​    mov ax，[0008]	ax = c389;cs = 0ff0;ip = 0108; ds = 2000

​    mov ax，[0002]	ax = ea66; cs = 0ff0; ip = 010B; ds = 2000



mov 指令占两个字节，jmp指令占三个



3.如果cs：ip指向的内存单元，那么它就作为CPU指令读取并执行



## 栈

**栈的规则是：先进后出，后进先出**





## cpu提供给栈机制

最基本的两个**PUSH**和**POP**。

**push ax表示将寄存器ax中的数据送入栈中**

**pop ax表示从栈顶取出数据送入ax**

**8086cpu的入栈和出栈操作都是以字为单位进行的**



**所有的数据从栈底进入，从栈顶出**



**任何时刻，ss：sp指向栈顶元素**



入栈时，栈顶从高地址向低地址方向增长



问题3.6：

sp = sp - 2;

栈为空，相当于栈中唯一的元素出栈。出栈后，sp = sp + 2；







pop指令功能：

将ss：sp指向的内存单元处的数据送入ax中

sp = sp + 2，ss：sp指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶



简单理解：push入栈	pop压栈





## 栈顶越界问题

ss：sp记录的栈顶的地址，依靠ss和sp可以保证在入栈和出栈的时候找到栈顶。

一个栈空间有16个字节，8个字空间。

当前栈空间为10001F-10010，如果发生栈越界以后，数据将会覆盖10020.

如果出现栈越界的情况，那么其他的栈空间可以存放具有其他用途的数据、代码等。如果不小心操作到了操作系统的栈空间，那么操作系统就会将你这个违规操作踢出去。

但是8086cpu不保证我们对栈的操作不会越界，8086cpu只知道栈顶在什么地方（ss：sp），而不会检查我们对栈的操作有多大。

8086cpu只考虑一个问题：当前的栈顶在何处，当前要执行的指令是那一条





## push、pop指令

push 寄存器	//将一个寄存器中的数据入栈

pop 寄存器	//出栈，用一个寄存器接受出栈的数据

push 段寄存器	//将一个段寄存器中的数据入栈

pop 段寄存器	//出栈，用一个段寄存器接收出栈数据

push 内存单元	//将一个内存字单元处的字入栈（栈操作都是以字为单位）

pop 内存单元	//出栈，用一个内存字单元接收出栈的数据



mov ax,1000	//将1000送入ax通用寄存器中

mov ds,as	//将ax中的数据送入ds段寄存器中

push [0]	//将1000：0处的字压入栈中

pop [2]	//出栈，出栈的数据送入1000：2中



问题3.7

初始栈为空，将ax、bx、ds中的数据送入栈

初始栈为空，偏移地址为sp = 0010

mov ax,1000

mov ss,ax

mov sp,0010

push ax

push bx

push ds



问题3.8



mov ax,1000

mov ss,ax

mov sp,0010	//空栈，初始化栈顶为0010

mov ax,001a

mov bx,001b



push ax

push bx	//将ax，bx送入栈



sub ax,ax

sub bx,bx	//两个相同的字相减为0



pop bx	//从栈中恢复ax，bx原来的数据，当前的栈顶内容是bx中原来的内容

pop ax	



用栈来暂存以后需要恢复的寄存器中的内容时，出栈的顺序和入栈的顺序要相反，因为最后入栈的寄存器的内容在栈顶，所以恢复的时候，要最先出栈。







问题3.9

利用栈交换ax和bx中的数据



mov ax,1000

mov ss,ax

mov sp,0010

mov ax,001a

mov bx,001b

push ax

push bx

sub ax,ax

sub bx,bx

pop ax	//执行pop ax后，栈顶的数据为ax原来的数据

pop bx



问题3.10

补全代码，在10000处写入字形数据2266

不能使用 mov 内存单元，寄存器这类指令

mov ax,1000

mov ss,ax

mov sp,2

mov ax,2266

push ax





**push、pop实质上就是一种内存传送指令，可以在寄存器和内存之间传递数据，与mov指令不同的是，push和op指令访问的内存单元的地址不是在指令中给出的，而是ss：sp指出的**

**push、pop等栈操作指令，修改的是sp，栈顶变化范围最大为：0-ffff**



## 栈的综述

8086cpu提供栈操作机制：

在ss、sp中存放栈顶的段地址和偏移地址

提供入栈和出栈指令，它们按照ss：sp指示的地址，按照栈的方式访问内存单元

push指令的执行步骤：sp=sp-2，向ss：sp指向的字单元中送入数据

pop指令的执行步骤：从ss：sp指向的字单元中读取数据，sp=sp+2

任意时刻，ss：sp指向栈顶元素

8086cpu只记录栈顶，栈空间的大小需要自己管理，不能越界

用栈来暂存以后需要恢复的寄存器的内容时，寄存器的出栈顺序要和入栈的顺序相反

push、pop实质上是一种内存传送指令





## 栈段

前面说过，我们可以将一段连续的内存空间定义成一个段，我们可以将长度为n（n<=64kb）的一组地址连续、起始地址为16的倍数的内存单元，当作栈空间来用，从而定义了一个栈段。

比如我们可以将10010到1001F这段长度为16字节的内存空间当作栈来使用。



问题：3.11

如果将10000-1ffff这段空间当成栈，栈空间的大小为64kb，栈底为1000：ffff，此时，ss：sp指向栈顶单元，当栈中只有一个元素的时候，ss=1000，sp=fffe，栈为空，就相当于栈中唯一的元素出栈了，出栈后，sp=sp+2；

sp原来等于fffe，加2后等于0，所以当栈顶为空的时候，ss=1000，sp=0；





问题3.12

一个栈最多可以设为多少？为什么?

push、pop等指令在执行的时候只能修改sp，所以栈顶的变化范围为0-ffff，从栈空的时候sp=0，知道栈满的时候sp=0；如果再次压栈，栈顶将环绕，覆盖了栈中原来的内容。

所以一个栈最大64kb；





## 段综述

如果要用一个段存放数据，那么这个段就是数据段

如果要用一个段存放代码，那么这个段就是代码段

如果要用一个段存放栈，那么这个段就说栈段







## 监测点3.2

1.

mov ax,1000

mov ds,ax

mov ax,2000

mov ss,ax

mov sp,0010	//这里设置了ss：sp的值

push [0]

push [2]

push [4]

push [6]

push [8]

push [A]

push [C]

push [E]



2.

补全程序，让他可以将10000-1000f中的8个字，逆序复制到20000-2000f中

mov ax,2000

mov ds,ax

mov ax,1000

mov ss,ax

mov sp,0

pop [e]

pop [c]

pop [a]

pop [8]

pop [6]

pop [4]

pop [2]

pop [0]







实验2：

debug使用

d使用：

**-d 段寄存器：偏移地址**

**-d 段寄存器：偏移地址 18	//查看1000：10-1000：18中的内容**

**-d 段寄存器：0	//查看当前代码段中的指令代码**	//所以这里只可以使用代码段寄存器cs

**ds和cs的区别，cs是指向代码的基地址，ds保存的是数据段的基地址**

**-d ss：0	栈段寄存器：偏移地址	//查看当前栈段中的内容**



e、a、u命令中使用段寄存器

-r ds

：1000

-e ds:0 11 22 33 44 55 66 //在1000：0的地方写入数据

-u cs:0	//以汇编指令的形式，显示当前代码段中的代码，0代表偏移地址

-r ds

:1000

-a ds:0	//以汇编指令的形式，想1000：0开始的内存单元写入指令







mov ax,2000

mov ss,ax

mov sp,10	//指派2000：0000-2000：000f为栈空间，初始化栈顶

mov ax,3123

push ax

mov ax,3366

push ax	//在栈中压入两个数据



**修改栈段寄存器ss的指令不会被显示出来**





试验任务：



mov ax,[0]	ax = 5bea

mov ax,[2]	ax = 00e0

mov bx,[4]	bx = 30f0

mov bx,[6]	bx = 2f34

push ax	sp = 00fe

push bx	sp = 00fc

pop ax	sp = 00fe

pop bx	sp = 0100

push [4]	sp = 00fe

push [6]	sp = 00fc





2.因为在栈里









