# 第一个程序

## 一个源程序从写出到执行的过程

1.编程汇编源程序

2.对源程序进行编译链接

3.执行可执行文件中的程序

## 源程序

assume cs:codesg

codesg segment

​	mov ax,0123

​	mov bx,0456

​	add ax,bx

​	add ax,ax

​	mov ax,4c00

​	int 21

codesg ends

end



### 伪指令

在汇编语言的源程序中，有两种指令，一种是汇编指令，一种是伪指令。

汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终被cpu执行。

而伪指令没有对应的机器指令，最终不被cpu执行。

伪指令是由编译器来执行的指令

****

xxx segment

​	:

​	:

xxx ends

segment和ends是成对使用的伪指令，这是在写被编译器编译的汇编程序时，必须要用到的一个伪指令。

**segment和ends的功能是定义一个段，segment代表开始，ends代表结束**

**segment和ends之间的汇编指令是这个段中存放的内容，这是一个代码段**





****

**end**

**end是一个汇编程序的结束标记，编译器在编译汇编程序的时候，如果碰到了伪指令end，那么久停止对源程序的编译。**

但是记得一定要写完了汇编程序，要加end，不然编译器在编译的过程中，久不知道程序应该在哪里结束了

分清楚end和ends的区别，ends是和segment成对使用的

而end是整个汇编程序的结束符号



****



**assume**

这条伪指令的含义为**假设**，他假设某一段寄存器和程序中的某一个用segment...ends定义的段相关联。

assume cs:codesg将用作代码段的段codesg和cpu中的段寄存器cs联系起来。



### 源程序

用汇编语言写的源程序，包括伪指令和汇编指令，最终的目的是编写成由汇编指令组成的给计算机执行的程序，而源程序中的伪指令是由编译器来处理的，它们并不会帮我们实现最终的编程效果。



程序最先以汇编指令的形式存在源程序中，经过编译、链接后转变称为机器码，存储在可执行文件中。



![](D:\Learn\3Week\Assembly\第四章\img\0.png)



### 标号

codesg就算一个标号，一个标号代表一个地址。比如codesg在segment的前面，作为一个段的名称，这个段的名称最终被编译、链接程序处理为一个段的段地址。



### 程序的结构

源程序是由一些段构成的，我们可以在这些段中存放代码、数据、或者将某个段当作栈空间。



编程运算2*3

1.首先定义一个段：

abc segment

​	:

abc ends



2.在这个段中写入汇编指令

abc segment

​	mov ax,2

​	add ax,ax

​	add ax,ax

abc ends

3.然后写处程序在哪里终止

abc segment

​	mov ax,2

​	add ax,ax

​	add ax,ax

abc ends

end

4.abc被当作代码段来用，所以应该将abc和cs联系起来

assume cs:abc

abc segment

​	mov ax,2

​	add ax,ax

​	add ax,ax

abc ends

end



### 程序返回

源代码经过编译、链接后转变称为机器码，存储在可执行文件中。

**一个程序p2在可执行文件中，则必须有一个正在运行的程序p1，将p2从可执行文件中载入内存后，将cpu的控制权交给p2，p2才能运行，p2开始运行后，p1暂停运行**

****

mov ax,4c00

int 21

这两条指令所实现的功能就是程序返回





**通知编译器一个段结束	段名 ends	伪指令	编译时，由编译器执行**

**通知编译器程序结束	end	伪指令	编译时，由编译器执行**

**程序返回	mov ax,4c00 int 21	汇编指令	编译时，由CPU执行**







## 编译

我在官网下载的masm，但是bin目录下编译有问题，所以在csdn上找的masm.exe编译器的

.asm为汇编源文件

.obj为编译过后的汇编文件（尝试使用notepad打开的时候蓝屏）

.lst列表文件

.crf交叉引用文件

****

书上的编译步骤：

1.输入masm打开汇编编译器

2.选择输出的.obj文件的目录已经名称

3.忽略文件的生成

4.忽略交叉文件引用（编译器将源程序直接翻译成目标我呢见过程中产生的中间结果）

5.下方会提示error和warning

一般来说，warning是警告，如果程序中有这个，可以编译，但是会产生一些漏洞或者其他不可预期的后果，error是无法通过编译的。





## 连接

使用link.exe进行连接

****

书上的编译方法：

1.找到.obj的存放位置，因为我的这个比较特殊，别的masm.exe生成.obj文件在当前目录下，我生成的在我的文档下，所以我是拷贝到masm这个目录下的

2.选择.exe的存放位置。（.exe就是我们的可执行程序）

3.忽略了镜像文件生成

4.忽略了库文件连接

**目标文件**。**输出是：可执行文件名、映像文件的生成、库文件的连接**。

代码编译完成以后，有一个警告

![](D:\Learn\3Week\Assembly\第四章\img\2.png)

这个警告是告诉我们，没有栈段！



连接的作用：

1.当源程序很大的时候，可以将它分成多个源程序文件来编译，每个源程序编译成目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件。

2.程序中调用了某个库文件的子程序，需要将这个库文件和该程序生成的目标文件连接在一起，生成一个可执行文件。

3.一个源程序编译后，得到了存有机器码的目标文件，目标文件有些内容不能直接用来生成可执行文件，连接程序将这些内容处理为最终可执行信息。所以在只有一个源程序文件，而不需要调用某个库中子程序的情况下，也必须用连接程序对目标程序进行处理，从而生成可执行文件。

**总而言之：连接的功能就是帮我们把一大堆源程序和库文件连接到一起，生成一个可执行文件**



## 简化方式进行编译和连接

**masm .asm文件的路径;	//记得分号，不然不会忽略中间的步骤**

**link .obj文件的路径;	//这里记得，千万不能自做主张的给路径后面加一个.obj**







## 1.exe的执行

为什么我们写了一串的程序，然而执行的时候并没有什么结果呢？

![](D:\Learn\3Week\Assembly\第四章\img\2.png)

因为这段程序没有任何的输出，说根本的我们只是进行了寄存器之间的操作。

![](D:\Learn\3Week\Assembly\第四章\img\3.png)

mov ax,4c00

int 21

这两句是程序的返回，还可以帮助编程者关闭打开后忘记关闭的文件。





## 谁执行可执行文件中的程序装载进入内存并使它运行

**dos中，可执行文件p1如果要运行，必须有一个正在运行的p2，p2将p1从可执行文件中载入内存，将cpu的控制权交给他，p1才可以运行，p1运行完毕后，应该将cpu的控制权交还给p2**



问题4.1

此时有一个正在运行的程序1.exe中的程序加载进入内存，这个正在运行的程序是什么？它将程序加载进入内存后，如果使程序得以运行？

应该是cmd.exe或者command.exe或者debug.exe将1.exe加载进入内存	//这条是自己猜的

command设置CPU的CS:IP指向程序的第一条指令(即程序的入口)。从而使程序得以运行； 

程序运行结束后，返回command中，CPU继续运行command。



问题4.2

程序运行结束后，返回到那里？

操作系统要提供一个shell（外壳）的程序，用户使用这个程序来操作计算机系统进行工作。

dos系统中有一个command.com,这个程序在dos中被称为命令解释器，也就是dos系统的shell。

command处理各种输入、命令或者要执行的程序的文件名。



**1.asm->编译（masm）->连接(link)->加载(command)->运行(cpu)**





## 程序执行过程跟踪

使用debug对程序进行跟踪。

dos运行一个程序，首先command将程序从可执行文件中载入内存，并执行。

command的程序加载，设置cs：ip指向程序的入口的操作是连续完成的，而当cs：ip指向程序入口，command就放弃了cpu的控制权，cpu开始运行，直到结束



debug可以将程序载入内存，设置cs：ip指向程序的入口，但debug不放弃对cpu的控制，所以我们可以使用debug来单步运行程序。



![](D:\Learn\3Week\Assembly\第四章\img\4.png)









cx存放的是程序的长度，1.exe中共有机器码15个字节，则1.exe加载以后，cx中的内容是000f

![](D:\Learn\3Week\Assembly\第四章\img\5.png)



程序加载后，ds中存放程序所在内存的段地址（ds），这个内存区的偏移地址为0，则程序所在的地址区的地址为ds：0



这个内存区的前256个字节存放的是psp，dos用来和程序进行通信。从256字节往后的空间存放的是程序。



从ds中可以得到psp的段地址sa，psp的偏移地址为0，则物理地址为sa*16+0



因为psp占用256（100h）字节，所以程序的物理地址是：

(sa+16)*16+0

段地址和偏移地址表示：sa+10：0

按照我的图片计算：

sa = ds+10:0	//当前ds的值是0b8a+10就是0b9a

![](D:\Learn\3Week\Assembly\第四章\img\6.png)



sa最终的出来的地址，就是当前程序的入口点，也就是cs的值



可以看到009a:0000 - 009a:001f中都是程序的机器码





到了 int 21的时候，使用p指令，屏幕上出现这句话

![](D:\Learn\3Week\Assembly\第四章\img\7.png)



这句话表示程序正常退出。



## 实验

2.debug跟踪2.exe的执行过程，写出每一步以后，相关寄存器的内容和栈顶的内容

1.ax = 07d0	bx = 0000	ds = 0b8a	ss = 0b9a	cs = 0b9a	ip = 0003	sp = 0000

2.ax = 07d0	bx = 0000	ds = 0b8a	ss = 07d0	cs = 0b9a	ip = 0008	sp = 0000

3.ax = 07d0	bx = 0000	ds = 0b8a	ss = 07d0	cs = 0b9a	ip = 000b	sp = 000A

4.ax = a93e	bx = 0000	ds = 0b8a	ss = 07d0	cs = 0b9a	ip = 000c	sp = 000c

5.ax = a93e	bx = 0356	ds = 0b8a	ss = 07d0	cs = 0b9a	ip = 000d	sp = 000e

6.ax = a93e	bx = 0356	ds = 0b8a	ss = 07d0	cs = 0b9a	ip = 000e	sp = 000c

7.ax = a93e	bx = 0356	ds = 0b8a	ss = 07d0	cs = 0b9a	ip = 000f	sp = 000a

8.ax = a93e	bx = 0356	ds = 0b8a	ss = 07d0	cs = 0b9a	ip = 0010	sp = 000c

9.ax = a93e	bx = 0356	ds = 0b8a	ss = 07d0	cs = 0b9a	ip = 0011	sp = 000e

10.ax = a93e	bx = 0356	ds = 0b8a	ss = 07d0	cs = 0b9a	ip = 0014	sp = 000e

11.ax = a93e	bx = 0356	ds = 0b8a	ss = 07d0	cs = 0b9a	ip = 000d	sp = 0008

注：11执行的相对应汇编代码是int 21



3.![](D:\Learn\3Week\Assembly\第四章\img\8.png)

可以看到ds=0b8a，cs=0b9a，内存区的前面有256个字节，所以相差16进制的10，简称psp的数据区





