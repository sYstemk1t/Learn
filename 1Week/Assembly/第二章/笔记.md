# 寄存器

**一个典型的CPU是由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连**

**运算器进行信息处理**

**寄存器进行信息存储**

**控制器控制各种器件进行工作**

**内部总线连接各种器件，在他们之间进行数据的传递**

**不同的cpu，寄存器的个数和结构是不同的**





## 通用寄存器

**8086cpu的所有的寄存器都是16位，可以存放两个字节，AX、BX、CX、DX这四个寄存器通常用来存放一般性的数据，被称为通用寄存器**

AX为例，寄存器的逻辑结构如图

![](D:\Learn\1Week\Assembly\img\6.png)

一个16位寄存器可以存储一个16位的数据。

一个16位寄存器所能存储的数据最大值为2^16-1，即65535



为了兼容上一代CPU，8086cpu的AX、BX、CX、DX这四个寄存器都可分为两个独立使用的8位寄存器

**AX可分为AH和AL**

**BX可分为BH和BL**

**CX可分为CH和CL**

**DX可分为DH和DL**



数据18在寄存器AX中存储

首先把18转换二进制

18  =  0001 0010

15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0    寄存器16位

0	   0	  0	   0	 0	  0	0	 0	0	0	0	1	0	0	1	0		数据存储方式，二进制方式



以AX为例子

15	14	13	12	11	10	9	8		7	6	5	4	3	2	1	0     16位寄存器

AH（高八位）															AL（低八位）

7	  6	  5	  4	   3      2	 1	0		 7	6	5	4	3	2	1	0 	8位寄存器

0	   0	  0	   0	 0	  0	0	 0		 0	0	0	1	0	0	1	0	 8位寄存器中的数据表示



AX的低八位(0~7)构成了AL存储器，高8位(8~15)构成了AH存储器。

AH和AL寄存器都是可以独立使用的八位寄存器

![](D:\Learn\1Week\Assembly\img\7.png)



一个八位寄存器所能存储的数据最大值是255





## 字在存储器中的存储

**字节：记byte，一个字节由8个bit组成，可以存在8位寄存器中。**

**字：记word，一个字由两个字节组成，这两个字节分别成为这个字的高位字节和低位字节**



高位字节										 低位字节

0	1	0	0	1	1	1	0			0	0	1	0	0	0	0	0

一个字可以存在一个16位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高八位寄存器和低八位寄存器中。



**任何数据，到了计算机中都是以二进制的方式存在的**

**十六进制数的一位相当于二进制数的四位，如0100 1110 0010 0000 可以表示为：4(0100)、E(1110) 2(0010)、0(0000)**

**由于一个内存单元可存放8位数据，CPU中的寄存器又可以存放n个8位的数据**



**十六进制后加H，二进制后加B**





## 汇编指令

mov ax,18	将18送入寄存器AX

mov ah,78	将78送入寄存器AH

add ax,8	将寄存器AX中的数据加上8

mov ax,bx	将寄存器变量BX中的数据送入寄存器AX

add ax,bx,	将AX和BX中的数值相加，结果存在AX中



指令											执行后AX中的数据									执行后BX中的数据

mov ax,4e20H							4E20H														0000H

add ax,1406H							 6226H														0000H

mov bx,2000H							6226H														2000H

add ax,bx								   8226H														2000H

mov bx,ax								  8226H													   8226H

add ax,bx								   044CH													  8226H

问题2-1：

因为ax为16位寄存器，只能存放4位16进制的数据，所以最高为1不能在ax中保存。







![](D:\Learn\1Week\Assembly\img\8.png)







这里其实有是有一个小坑的，ax和bx都是16位寄存器，al和bl都是八位寄存器。

add al,bl 	al = 1a,bl = 26    1a+26 = 40

add ah,bl	ah = 0 + 26H = 26H;  al = 40H,  ah+bl = 2640H;

add bh,al	bh = 0026H; al = 40H;  bh+al = 2640H;

mov ah,0	意思就是把高八位归为0

add al,85H ax中的低位寄存器加85

​					40 + 85 = 00C5   //因为是使用低位寄存器运算

add al,96H al也是一个低八位寄存器

​					c5 + 93 = 0158   //015为16位寄存器表示方法，8位寄存器中，舍弃掉高位，答案为58





在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的。

错误写法：

mov ax,bl	//因为一个是八位寄存器，一个是十六进制。





## 物理地址

CPU访问内存单元的时候，要给出内存单元的地址。所有的内存单元构成存储空间是一个一维的线性空间，每一个内存单元 在这个空间都有唯一的地址。

CPU通过地址总线送入存储器的，必须是一个内存单元的物理地址。





## 16位CPU的结构

8086CPU是上一代CPU(8080、8085)等是8位机器，8086是16位，也可以说8086是16位结构的CPU。



16位CPU的结构：

​	运算器一次最多可以处理16位数据；

​	寄存器的最大宽度为16；

​	寄存器和运算器之间的通路为16；





## 8086CPU给出物理地址的方法

8086CPU有20位地址总线 ，可以传送20位地址，达到1MB的寻址能力。

8086CPU又是16位的架构，在内部一次性处理、传输、暂时存储的地址为16位。

从8086CPU的内部结构来看，如果将地址从内部简单发出，那么它只能送出16位地址，表现出的寻址空间只有64KB。



![](D:\Learn\1Week\Assembly\img\9.png)



**CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址。**

**段地址和偏移地址通过内部总线送入一个称为地址加法器的部件。**

**地址加法器将两个十六位地址合成一个二十位的物理地址**

**地址加法器通过内部总线将二十位的物理地址送入输出控制电路**

**输入输出控制电路将二十位物理地址送上地址总线**

**二十位的物理地址被地址总线送到存储器**



地址加法器采用物理地址=短地址*16+偏移地址的方法用段地址和偏移地址合成物理地址。



![](D:\Learn\1Week\Assembly\img\10.png)



段地址*16计算

十六进制数字:2H	二进制形式为10，左移运算

左移位数		二进制		十六进制		十进制

0					10B				2H				2

1					100B			  4H				4

2					1000B			8H				8

3					10000B		  10H			  16

4					100000B		20H				32



观察规律：

**1个数据的二进制形式左移1位，相当于该数据乘以2**

**1个数组的二进制形式左移n位，相当于该数据乘以的N次方**

**地址加法器就是以二进制形式存放的段地址左移4位**



**一个数据的十六进制形式向左移1位，相当于乘以16；**

**一个数据的十进制形式向左移1位，相当于乘以10；**

**一个X禁止的数据左移1位，相当于乘以X；**





## ‘段地址’*16+偏移地址

段地址’*16+偏移地址 = 物理地址的本质含义是：CPU在访问内存时，用一个基础地址(地址段*16)和一个相对于寄存地址的偏移地址相加，给出内存单元的物理地址。

比如说2826这个数据

分开写在两张可以写下三位数据的纸条

200	//第一张

826	//第二张

200是段地址，826是偏移地址

200(段地址)*10+826(偏移地址) = 2826(物理地址)





## 段的概念

内存没有分段，段的划分来自于CPU，由于8086CPU用“基础地址(段地址*16)+偏移地址 = 物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。

![](D:\Learn\1Week\Assembly\img\11.png)

比如途中的10000H~100FFH的内存单元组成一个段，该段的起始地址（基础地址）位10000H，段地址位1000H，大小为100H。

将若干地址连续的内存单元看作一个段。

两个需要注意的点：

​	**偏移地址为16位，16位地址的寻址能力位64KB**

​	**一个段的长度最大为64KB**



CPU



**CPU访问内存单元时，必须像内存提供内存单元的物理地址。8086CPU在内部用段地址和偏移地址移位相加的方法最终形成的物理地址。**





**CPU可以用不同的段地址和偏移地址来形成统一个物理地址.**





**数据存在内存2000:1F60单元中；**

**数据存在内存的2000H段中的1F60H单元中；**






## 段寄存器

8086CPU有4个段寄存器：CS、DS、SS、ES；



## CS和IP

**CS为代码段寄存器；**

**IP为指令指针寄存器；**

CS是代码段寄存器，IP是指令指针寄存器（相当于偏移地址）。修改CS、IP的指令不同于修改通用的寄存器值的指令，修改通用寄存器的值可以用mov 指令（mav ax,123），mov指令被称为传送指令。修改CS、IP的指令是jmp指令。jmp指令被称为转移指令。

（1）同时修改代码段寄存器和指令指针寄存器，形如jmp 段地址：偏移地址。

jmp2AE3:3,执行后：CS=2AE3H，IP=0003H,CPU将在2AE33H处读取指令

（2）仅想修改IP的内容，形如“jmp 某一合法寄存器”,功能是用某一合法寄存器中的值修改IP的内容

jmpax，指令执行前：ax=1000H,CS=2000H,IP=0003H

执行后结果：ax=1000H,CS=2000H,IP=1000H。







一般来说，CPU在访问内存的时候要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。段寄存器提供段地址。8086CPU有4个段寄存器：CS、DS、ES、SS。典型的提供段地址和偏移地址的寄存器为CS和IP寄存器。也就是说，CPU会将CS:IP合成的物理地址指向的内容当作指令执行。CPU执行指令的步骤一般是：
--------------------- 
（1）将CS、IP中的内容送入地址加法器（段地址*16+偏移地址）合成物理地址。

（2）地址加法器将物理地址送入输入输出控制电路

（3）输入输出控制电路将物理地址送上地址总线

（4）然后CPU从物理地址指向的内存单元读取机器指令，并将机器指令通过数据总线送入CPU的输入输出控制电路。

（5）输入输出控制电路将读取的指令送入指令缓冲器，同时IP的内容更新为原内容加指令长度。

（6）然后，执行控制器执行机器指令，并将执行后的内容送入相应的寄存器。





**在编程时，可以根据需要将一组内存单元定义为一个段。我们可以将长度为N（N<=64KB,因为偏移地址长度为16位，最大为64KB）的一组代码存在一组连续、起始地址为16的倍数的内存单元中。这样，这段内存就可以看成是代码段，用来存放代码的。**



在win Xp上做的一个小实验

cmd >> debug  

用R命令改变、查看CPU寄存器的内容

![](D:\Learn\1Week\Assembly\img\12.png)

用D命令查看内存中的内容

![](D:\Learn\1Week\Assembly\img\13.png)

用E命令改写内存中的内容

![](D:\Learn\1Week\Assembly\img\14.png)









## 修改cs、ip指令

mov指令不能用于设置CS、IP的值。

使用jmp指令修改CS、IP的值。



