# 编译和链接

## 被隐藏了的进程

```c
#include <stdio.h>
int main()
{
    printf("hello world\n");
    return 0;
}
```



使用gcc进行编译，不需要加任何参数，会生成一个a.out的一个可执行文件。

新版本的ubuntu已经不集成gcc，需要自己安装..



在这一条命令的背后，有四个步骤，分别是**预处理、编译、汇编、链接**

![](F:\Learn\4Week\misc\2\img\1.png)



## 预处理

还是使用hello.c，我们来看编译器的预处理帮我们做了哪些事情

预处理过程主要处理源代码中以'#'开头的指令

**将所有的#define删除，展开宏定义**

**处理所有条件预处理指令，将被包含的文件插入到预编译指令中,'#if #ifdef'**

**处理所有的#include指令，将被包含文件插入到预处理位置**

**删除所有的注释'//'和'//'**

**添加行号和文件名标识**

**保留所有的#pragrma编译器指令，因为编译器需要他们**

![](F:\Learn\4Week\misc\2\img\2.png)



通过图可以简单的看到，第一步就是添加了行号和文件名标识



### 编译

**编译的过程就是将预编译后的文件优化生成相对应的汇编代码**

我的是64位系统，应该会生成64位的汇编代码

![](F:\Learn\4Week\misc\2\img\5.png)



### 汇编

**gcc命令只是后台程序的包装，它会根据不同的参数调用预编译程序cc1、汇编器as、连接器id**



**汇编器是将汇编代码转换成机器可以执行的代码，每一个汇编语法都对应一条机器指令**



![](F:\Learn\4Week\misc\2\img\6.png)



查看的时候是乱码，可能是因为有些汇编指令翻译称为了二进制代码，但是不支持命令行查看



### 链接

**简单的来说，链接就是去找一些库文件或者函数，c语言的实现里并不会对操作系统进行操作，这个时候需要调用一些系统函数，比如pritnf，它是需要打印显示在屏幕上的，就需要去链接一些标准的输入输出库**







## 编译器做了什么

编译器就是将高级语言翻译成机器语言的一个工具。

编译器共执行了六步：**扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化**



### 语法分析

首先源代码被输入到扫描器，扫描器的任务很简单，简单的进行语法分析，运用一个类似有限状态机的算法可以很轻松的将源代码中的字符序列分割成一系列的记号

![](F:\Learn\4Week\misc\2\img\7.png)

分析后一般会产生如下几类：**关键词、标识符、字面量、特殊符号**



使用Lex程序可以实现语法扫描，它会按照用户之前描述好的规则将输入的字符串分割成一个个记号。



## 语法分析

语法分析其将会对扫描器产生的记号进行语法分析，从而产生语法树。

由语法分析其生成的语法树就说以表达式为节点树

![](F:\Learn\4Week\misc\2\img\8.png)

语法分析其有一个工具叫做yacc，它也想lex一样，可以根据用户给定的语法规则对输入的记号序列进行解析



## 语义分析

语义分析仅仅是完成了对表达式层面的分析，但是它并不了解这个语句是否真的有意义。

编译器所能理解的语义是静态语义，静态语义是指在编译期间可以确定的语义



静态语义通常包括声明和类型的匹配，类型的转换。比如char型转换为int型

动态语义一般指在运行期的语义相关的问题，比如将0做为除数是一个运行期语义错误



![](F:\Learn\4Week\misc\2\img\9.png)



语义分析完成后，语法树的表达式都标识了类型。







### 中间语言生成

源码级优化在不同的编译器中可能有不同的定义或一些其他的差别。

![](F:\Learn\4Week\misc\2\img\10.png)

相对于语义分析后，中间语言生成后，将表达式进行求值。

中间代码有很多类型，比较常见的有：三址代码和p-代码。

```c
x = y op z
```

上面的代码的意思是：将变量y和z进行op操作后，赋值给x

```c
x = a+b;
```

简单的理解，三址码就是这样，x = 变量a+变量b





### 目标代码生成与优化

编译器后端包括代码生成器和目标代码优化器。

代码生成器将中间代码转换称为机器代码，这个过程十分依赖目标机器，因为不同的机器有着不同的字长、寄存器、整型数据类型和浮点数数据类型

```assembly
movl index,%ecx	;ecx是通用寄存器,index是数据
addl $4,%ecx	;ecx = ecx + 4
mull $8,%ecx	;ecx = ecx * 8
movl index,%eax	;
movl %ecx,array(,eax,4)
```

最后目标代码优化器对上述的目标代码进行优化，比如找到合适的寻址方式，使用位移来代替乘法运算、删除多余的指令等



至今没有一个编译器能够完整支持c++语言标准所规定的所有语言特性





## 连接器年龄比编译器长

如果将上万行的c语言代码放在一个文件中进行编译，即使电脑的性能再好，也是需要一定的时间的



在很古老的计算机的时代，当时程序员先把一个程序在纸上写好，当时没有高级语言，没有汇编语言，使用的存储设备之一就说纸带，在纸带上打相对应的孔

八音盒就是一个比较形象的例子，在相对应的地方设置音符，如果转动到了那个地方，出声，不到的时候是不会发出声音的







## 静态链接

将一个程序多个功能拆分开，然后进行组装，这个过程就是链接，链接的主要内容就是把各个模块之家能相互引用的部分处理好，使得各个模块之间能正常的衔接。



模块的源代码文件经过编译成目标文件，目标文件和库文件一起链接形成了可执行文件。





最常见的库是运行时库，它是支持程序运行的基本函数的集合



