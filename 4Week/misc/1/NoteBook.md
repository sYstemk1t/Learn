# 第一章

## 从Hello World说起

```c
#include <stdio.h>
int main()
{
    printf("Hello,World");
    return 0;
}
```





![](F:\Learn\4Week\misc\1\img\1.jpg)



1.因为未被编译的代码仅仅只是代码并不是可执行文件。

2.做了四步，编译，汇编，链接，生成

3.汇编出的可执行文件是二进制的机器码。

4.包含stdio库。包含进来意味着可以使用这个库。c语言库是c代码组成的。

5.不一样，因为他们的架构不同，操作系统的架构也同，所以对应的汇编语言也不是相同的

6.Hello World程序被编译成为可执行文件然后运行。操作系统提供外壳给编译器，编译成功后，执行。从mainCRTStart执行。到return结束。

7.可以。需要汇编语言，汇编语言可以直接在硬件操作。

8.printf函数实现int printf ( const char * format, ... );

9.

![](F:\Learn\4Week\misc\1\img\2.PNG)









## 站得高，望得远



每个层次之间相互通信的时候，必须遵守一个协议，我们一般将其称为接口。

除了硬件和应用程序，其他都是所谓的中间层，每个中间层都是对它下面的那层的包装和扩展。

操作系统应用程序编程接口（api）。



运行库使用操作系统提供的系统调用接口，系统调用接口在实现中往往以软件中间的方式提供，比如linux使用0x80号中断作为系统调用接口，windows使用0x2E号中间作为系统调用接口（从Windows xp sp2开始，这种方式不在延续）



## 操作系统做什么



## 不要让cpu打盹

这个应该就是多线程、多任务的概念。





## 设备驱动

Unix中，硬件设备的访问形式和访问普通的文件形式一样；

Windows中，图形硬件被抽象成了GDI，声音和多媒体设备被抽象成了DirectX对象；硬盘被抽象成了普通文件系统。



## 内存不够怎么办



进程的总体目标是希望每个进程从逻辑上来看都可以独占计算机的资源。

操作系统的多任务功能使得CPU能够在多个进程之间很少的共享。



简单的内存分配策略：

1.地址空间不隔离

2.内存使用效率低

3.程序运行地址不确定



解决上述问题的办法就是：增加中间层，即使用一个简介的地址访问方法，在汇编中称为偏移地址



## 关于隔离

在32位系统中，最大可寻址空间位2^32，这个数组的大小决定了内存地址的起始。

内存地址分为两种：虚拟地址和物理地址；

物理地址是在计算机中存在的，并且有且只有一个地址。

虚拟地址其实并不村子啊，每个进程都有自己独立的虚拟空间，而且每个进程只能访问自己的地址空间，这样就有效的做到了进程的隔离



## 分段

把一段与程序所需要的内存空间大小的虚拟空间映射到某个地址空间。





## 分页

分页的基本方法是把地址空间人为的划分成固定大小的页，每一页的大小由硬件决定，或硬件支持多种大小的页，由操作系统选择决定页的大小。但是在同一时刻只能选择一种通过大小，所以对操作系统来说，页就是固定大小的。



![](F:\Learn\4Week\misc\1\img\3.png)

MMU的部件来进行映射





