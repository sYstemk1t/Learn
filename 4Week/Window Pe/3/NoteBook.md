# PE



## PE的数据组织方式

**PE的数据组织是大量的字节码与数据结构的有机融合**







## 与PE有关的基本概念

![](F:\Learn\4Week\Window Pe\3\img\0.png)

### 地址

PE中涉及的地址有四类：

*虚拟内存地址

*相对虚拟内存地址

*文件偏移地址

*特殊地址

**32位CPU的寻址能力为4GB，但是如果物理内存不能到达这个值，操作系统和CPU的内存管理单元共同作用，为用户提供虚拟内存呢的管理机制**



**假设操作系统设一个进程独立拥有4GB内存，按照固定的大小将这4GB空间分割成N个页，一般存储再一个“交换文件”的磁盘文件中。再Windows Xp系统中，交换文件为pagefile.sys**



1.虚拟内存地址

用户的PE文件被操作系统加载进入内存后，PE对应的进程支配了自己独立的4GB虚拟空间。在这个空间中定义的地址称为虚拟内存地址，所以虚拟内存地址的范围是00000000-0fffffff。在PE中，进程本身被解释为：**进程的基地址+相对虚拟内存地址**





2.相对虚拟内存地址

一个进程被操作系统加载到虚拟内存空间后，其相关的动态链接库也会加载。这些同时加载进入进程地址空间的文件称为模块。

**每一个模块在加载的时候都会有一个基地址，也就说预先告诉操作系统：它会占用4GB空间的哪个部分。不同模块的基地址是不同的，如果两个模块的基地址相同，就由操作系统决定这两个模块在虚拟空间中的位置**



![](F:\Learn\4Week\Window Pe\3\img\1.png)

**相对虚拟内存地址是对于模块而言的，虚拟内存地址是相对整个地址空间而言**



3.文件偏移地址

文件偏移地址和内存无关，它是指某个位置距离文件头的偏移



4.特殊地址

在PE中还有一种特殊地址，其计算方式并不是从文件头算起，也不是从内存某个模块的基址算起，而是从某个特定的位置算起。**资源表里出现过这样的地址**





 ### 指针

Windows下的可执行文件是PE的一种，这种文件中包含除了代码及数据段的相关数据以外，还包含许多与可执行文件有关的其他数据，比如函数调用、PE图标、内涵导出函数等

PE中由一个数据结构为数据目录，其中包含了所有可能的数据类型。

**导出表、导入表、资源表、异常表、属性证书表、重定位表、调试数据、Architecture、Global Ptr、线程局部存储、加载配置表、绑定导入表、IAT、延迟导入表和CLR运行时头部**





### 节

Windows操作系统通常对不同用途的数据设置不同的访问权限。





节就说存放不同类型的数据（代码、数据、常量、资源）的地方，不同的节具有不同的访问权限。



**节是PE文件中存放代码或者数据的基本单元**

**一个节中的所有原始数据必须被加载到连续的内存空间中**



从操作系统的角度来看，节是相同属性的数据的结合，尽管有些节的数据类型不同，分别属于不同的数据目录，但由于其访问属性相同，便被归类与同一节中。这个节最终可能会占用一个或多个页面；但是无论有多少个节，所有相关也面都会被赋予相同的页属性。

**属性包括只读、只写、可读、可写等**



在汇编语言中以“.”开头的一些微指令其实就说在声明不同的数据类型。比如".data"声明的是初始化数据，“.data?”声明的是未初始化数据，“.code”声明的是可执行代码等。



因为是看了程序员那本然后看的这本，在Linux的ELF文件中，.data存放的是已初始化数据，.test存放的是可执行代码，.bss存放的是未初始化的变量

**在ELF文件中比较好玩的是，初始化为0，也会被存放到.bss段中**





### 对齐

PE中规定了三类对齐：

*数据在内存中的对齐

*数据在文件中的对齐

*资源文件中资源数据的对齐



#### 内存对齐

由于Windows操作胸对内存属性的设置以页为单位，通常情况下，节在内存中的对齐单元至少是一页大小。对于32位Windows xp sp2来说，这个值是4字节（1000h），对于64位操作系统来说，这个值是8字节（2000h）





#### 文件对齐

文件对齐一般都以一个物理扇区的大小作为对齐值，即512字节，十六进制表示为200h。

**数据段、代码段等起始地址都是200h的倍数**



#### 资源数据对齐

资源文件中，资源字节码部分一般要求以双字（4字节）方式对齐





### Unicode字符串

Unicode是继Ascii字符后的另一种编码，也称万国码。严格意义来说：Ascii码的每个字符使用7位表示，Unicode则使用全16位标识一个字符。Unicode字符串中每个字符均为双字节。



**Unicode兼容Ascii码，Unicode编码的前128个字节代表Ascii码，剩下的128个，则是对Ascii的扩展，比如对汉字的扩展**



**中国和韩国还有日本使用的象形文字占用的0x3000-0x9fff**



汇编语言中，Unicode被定义为一个结构体：

```assembly
typedef struct _UNICODE_STRING{
	USHORT Length;	//字符串长度
	USHORT MaximumLength;	//字符串缓冲区长度
	PWSTR Buffer;		//字符串缓冲区
}UNICODE_STRING, *PUNICODE_STRING;
```

**Unicode字符串结尾并不一定是“\0”**





## PE文件结构

### 16位系统下的PE结构

DOS头部分见证了PE的强大兼容性，为了保证兼容性，在PE里依然保留了16位系统下的标准可执行文件所文件头部(DOS MZ头)和指令代码。

Linux ELF文件也有一个头文件，它的头部文件一次是“DEl”、“E”、“L”、“F”

#### DOS MZ头

DOS头共分为两部分：DOS头冗余数据

![](F:\Learn\4Week\Window Pe\3\img\2.png)



```c
typedef struct _IMAGE_DOS_HEADER { // DOS .EXE 头结构定义开始 文件中的位置（偏移量）
WORD e_magic; // 魔术数字 0x00000000-0x00000001
WORD e_cblp; // 文件最后页的字节数 0x00000002-0x00000003
WORD e_cp; // 文件页数 0x00000004-0x00000005
WORD e_crlc; // 重定位元素个数 0x00000006-0x00000007
WORD e_cparhdr; // 以段落为单位的头部大小 0x00000008-0x00000009
WORD e_minalloc; // 所需的最小附加段 0x0000000A-0x0000000B
WORD e_maxalloc; // 所需的最大附加段 0x0000000C-0x0000000D
WORD e_ss; // 初始的堆栈段(SS)相对偏移量值 0x0000000E-0x0000000F
WORD e_sp; // 初始的堆栈指针(SP)值 0x00000010-0x00000011
WORD e_csum; // 校验和 0x00000012-0x00000013
WORD e_ip; // 初始的指令指针(IP)值 0x00000014-0x00000015
WORD e_cs; // 初始的代码段(CS)相对偏移量值 0x00000016-0x00000017
WORD e_lfarlc; // 重定位表在文件中的偏移地址 0x00000018-0x00000019
WORD e_ovno; // 覆盖号 0x0000001A-0x0000001B
WORD e_res[4]; // 保留字(一般都是为确保对齐而预留) 0x0000001C-0x00000023
WORD e_oemid; // OEM 标识符(相对于 e_oeminfo) 0x00000024-0x00000025
WORD e_oeminfo; // OEM 信息，即 e_oemid 的细节 0x00000026-0x00000027
WORD e_res2[10]; // 保留字(一般都是为确保对齐而预留) 0x00000028-0x0000003B
LONG e_lfanew; // 新 exe 头在文件中的偏移地址 0x0000003C-0x0000003F
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; //DOS .EXE 头结构定义结束；引用结构名：IMAGE_DOS_HEADER，结构指针名：PIMAGE_DOS_HEADER
```

![](F:\Learn\4Week\Window Pe\3\img\4.png)

可以简单的看到MZ标志，并且Hello.exe的代码只写了一条pritnf



#### DOS Stub

由于DOS Stub的大小不固定，因此DOS头的大小也是不固定的，DOS Stub部分是该程序在DOS系统下运行的指令字节码

使用debug查看一下：

![](F:\Learn\4Week\Window Pe\3\img\5.png)







### 32位系统下的PE结构

在16位系统中，PE头和PE数据部分被当作是冗余数据；在32位系统中，刚好相反，DOS头是冗余数据。

